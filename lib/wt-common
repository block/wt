#!/usr/bin/env bash
#
# wt-common — Shared config and helpers for wt-* scripts
# =========================================================
#
# Centralizes paths and small helpers used by the worktree tooling suite:
#   - wt-add
#   - wt-switch
#   - wt-choose
#   - wt-metadata-import
#   - wt-metadata-export
#   - wt-remove
#

# ─────────────────────────────────────────────────────────────────────────────
# Multi-repo context support
# ─────────────────────────────────────────────────────────────────────────────
# The wt toolkit supports multiple repository contexts. Each context has its
# own configuration stored in ~/.wt/repos/<name>.conf
#
# Configuration is loaded at runtime via parsing (not sourcing), so context
# switches take effect immediately without requiring shell reload.
# ─────────────────────────────────────────────────────────────────────────────

# Clear all WT_* config variables to allow fresh reload
# Used before wt_read_config() when we need to pick up context changes
# in the current shell (e.g., completions, help)
wt_clear_config_vars() {
  unset WT_MAIN_REPO_ROOT
  unset WT_WORKTREES_BASE
  unset WT_IDEA_FILES_BASE
  unset WT_ACTIVE_WORKTREE
  unset WT_BASE_BRANCH
  unset WT_METADATA_PATTERNS
  unset WT_CONTEXT_NAME
}

# Parse config file into shell variables (no sourcing)
# Only sets variables that aren't already set in the environment
# Args: $1 = config file path (default: ~/.wt/current)
#       $2 = "force" to clear existing variables first (for in-shell reload)
#
# When reading ~/.wt/current, it contains just the context name.
# The actual config is then loaded from ~/.wt/repos/<name>.conf
wt_read_config() {
  local config_file="${1:-$HOME/.wt/current}"
  local force="${2:-}"

  # If force mode, clear existing variables first (for in-shell reload after context switch)
  if [[ "$force" == "force" ]]; then
    wt_clear_config_vars
  fi

  [[ ! -f "$config_file" ]] && return 1

  # If this is the current context file, read context name and load from .conf
  if [[ "$config_file" == "$HOME/.wt/current" ]]; then
    local context_name
    context_name="$(head -1 "$config_file" | tr -d '[:space:]')"
    [[ -z "$context_name" ]] && return 1

    # Set context name for display purposes
    : "${WT_CONTEXT_NAME:="$context_name"}"

    # Now read the actual config from .conf file
    config_file="$HOME/.wt/repos/${context_name}.conf"
    [[ ! -f "$config_file" ]] && return 1
  fi

  local key value current_val
  while IFS='=' read -r key value; do
    # Skip empty lines and comments
    [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
    # Strip quotes from value
    value="${value#\"}"
    value="${value%\"}"
    # Only set if not already set in environment (allows env override)
    # Use eval with proper escaping for both bash and zsh compatibility
    eval "current_val=\"\${$key:-}\""
    if [[ -z "$current_val" ]]; then
      eval "$key=\"\$value\""
    fi
  done < <(grep -E '^WT_[A-Z_]+=' "$config_file" 2>/dev/null)
}

# Read wt.* keys from the repo's local git config.
# If CWD is inside a worktree, reads from the main repo's .git/config
# (git config --local in a worktree reads from the main repo automatically).
#
# Requires three core keys (worktreesBase, ideaFilesBase, baseBranch) to be
# set. mainRepoRoot is always auto-derived from git-common-dir (the main
# repo's .git parent) and is not configurable. If partially configured,
# prints a warning to stderr and applies nothing. Optional keys
# (activeWorktree, metadataPatterns) are applied only when all required keys
# are present.
#
# Sets variables unconditionally — git local config has highest priority.
wt_read_git_config() {
  # Only proceed if we're inside a git repo or worktree
  local repo_root
  repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 0

  # Read all wt.* keys into local variables
  local gc_worktrees_base="" gc_idea_files_base=""
  local gc_active_worktree="" gc_base_branch="" gc_metadata_patterns=""
  local has_any=false

  local key value line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    key="${line%% *}"
    value="${line#* }"
    has_any=true

    # git config keys are case-insensitive; lowercase for matching
    # (use tr for bash 3.2 compatibility — ${key,,} requires bash 4.0+)
    local lkey
    lkey="$(printf '%s' "$key" | tr '[:upper:]' '[:lower:]')"
    case "$lkey" in
      wt.worktreesbase)     gc_worktrees_base="$value" ;;
      wt.ideafilesbase)     gc_idea_files_base="$value" ;;
      wt.activeworktree)    gc_active_worktree="$value" ;;
      wt.basebranch)        gc_base_branch="$value" ;;
      wt.metadatapatterns)  gc_metadata_patterns="$value" ;;
    esac
  done < <(git config --local --get-regexp '^wt\.' 2>/dev/null)

  # Nothing found — not a wt-configured repo, silently return
  [[ "$has_any" == "false" ]] && return 0

  # Validate: all three required keys must be present
  local -a missing=()
  [[ -z "$gc_worktrees_base" ]]  && missing+=("wt.worktreesBase")
  [[ -z "$gc_idea_files_base" ]] && missing+=("wt.ideaFilesBase")
  [[ -z "$gc_base_branch" ]]     && missing+=("wt.baseBranch")

  if [[ ${#missing[@]} -gt 0 ]]; then
    printf "wt: incomplete git local config in %s — missing: %s\n" \
      "$repo_root" "${missing[*]}" >&2
    printf "wt: git local config ignored; falling back to context config\n" >&2
    return 0
  fi

  # Derive main repo root from git-common-dir (the main repo's .git parent).
  # git-common-dir always points to the main repo's .git, even from worktrees.
  WT_MAIN_REPO_ROOT="$(cd "$(git rev-parse --git-common-dir)/.." && pwd -P)"

  # All required keys present — apply unconditionally (highest priority)
  WT_WORKTREES_BASE="$gc_worktrees_base"
  WT_IDEA_FILES_BASE="$gc_idea_files_base"
  WT_BASE_BRANCH="$gc_base_branch"

  # Optional keys: apply if present
  [[ -n "$gc_active_worktree" ]]   && WT_ACTIVE_WORKTREE="$gc_active_worktree"
  [[ -n "$gc_metadata_patterns" ]] && WT_METADATA_PATTERNS="$gc_metadata_patterns"

  return 0
}

# Load config: git local config first (highest priority), then context .conf file
wt_read_git_config
wt_read_config "$HOME/.wt/current" 2>/dev/null || true

# Fallback defaults (used when no context is configured or config missing values)
# These provide backward compatibility for single-repo setups
# Main monorepo root (where `git worktree` is managed)
: "${WT_MAIN_REPO_ROOT:="$HOME/.wt/repos/repo/base"}"

# Base directory where new worktrees will be created by default
: "${WT_WORKTREES_BASE:="$HOME/.wt/repos/repo/worktrees"}"

# Base directory for project metadata vault (IDE configs: .ijwb, .idea, .vscode, etc.)
: "${WT_IDEA_FILES_BASE:="$HOME/.wt/repos/repo/idea-files"}"

# Symlink path that points to the currently active worktree (for IDE integration)
: "${WT_ACTIVE_WORKTREE:="$HOME/Development/java"}"

# Default primary branch to sync from when creating new worktrees
: "${WT_BASE_BRANCH:="master"}"

# Project metadata patterns to preserve across worktrees (space-separated)
: "${WT_METADATA_PATTERNS:=""}"

# Context name (for display purposes)
: "${WT_CONTEXT_NAME:=""}"

# ─────────────────────────────────────────────────────────────────────────────
# Path helpers
# ─────────────────────────────────────────────────────────────────────────────

# Expand ~ to $HOME in a path (bash doesn't expand ~ in variable assignments
# or interactive read input)
_wt_expand_path() {
  local path="$1"
  [[ "$path" == "~" ]] && path="$HOME"
  echo "${path/#\~\//$HOME/}"
}


# ─────────────────────────────────────────────────────────────────────────────
# Color support (only if output is a TTY)
# ─────────────────────────────────────────────────────────────────────────────
# Check if either stdout or stderr is a TTY (for interactive use)
# Use $'...' syntax to ensure escape sequences are properly interpreted
if [[ -t 1 || -t 2 ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[1;33m'
  BLUE=$'\033[0;34m'
  BOLD=$'\033[1m'
  NC=$'\033[0m' # No Color
else
  RED=''
  GREEN=''
  YELLOW=''
  BLUE=''
  BOLD=''
  NC=''
fi

# ─────────────────────────────────────────────────────────────────────────────
# Output helpers
# ─────────────────────────────────────────────────────────────────────────────

# Print to stderr (for UI messages, prompts, etc.)
echoerr() {
  printf "%s\n" "$*" >&2
}

# Print error message with red "Error:" prefix to stderr
error() {
  printf "${RED}Error:${NC} %s\n" "$*" >&2
}

# Print success message with green checkmark to stdout
success() {
  printf "${GREEN}✓${NC} %s\n" "$*"
}

# Print warning message with yellow warning symbol to stderr
warn() {
  printf "${YELLOW}⚠${NC}  %s\n" "$*" >&2
}

# Print info message with blue info symbol to stdout
info() {
  printf "${BLUE}ℹ${NC}  %s\n" "$*"
}

# Show the context banner if contexts are configured
# Output goes to stderr so it doesn't interfere with command output
wt_show_context_banner() {
  local repos_dir="$HOME/.wt/repos"
  local current_context=""

  # Only show banner if contexts are configured
  if [[ ! -d "$repos_dir" ]] || ! compgen -G "$repos_dir/*.conf" >/dev/null 2>&1; then
    return 0
  fi

  # Read current context name from ~/.wt/current
  if [[ -f "$HOME/.wt/current" ]]; then
    current_context="$(head -1 "$HOME/.wt/current" | tr -d '[:space:]')"
  fi

  if [[ -n "$current_context" ]]; then
    printf "${BLUE}[Context: %s]${NC} ${YELLOW}(wt context to switch)${NC}\n" "$current_context" >&2
  else
    printf "%s[No context set]%s %s(wt context to switch)%s\n" "$YELLOW" "$NC" "$YELLOW" "$NC" >&2
  fi
}

# Source a library script from lib/ directory
# Usage: wt_source <script_name>
# Requires LIB_DIR to be set by the calling script (usually SCRIPT_DIR/../lib)
wt_source() {
  local script="$1"
  local lib_dir="${LIB_DIR:-}"

  if [[ -z "$lib_dir" ]]; then
    echo "Error: LIB_DIR not set before calling wt_source" >&2
    return 1
  fi

  if [[ -f "$lib_dir/$script" ]]; then
    . "$lib_dir/$script"
  elif [[ -f "$HOME/.wt/lib/$script" ]]; then
    . "$HOME/.wt/lib/$script"
  else
    echo "Error: Cannot find $script in $lib_dir or ~/.wt/lib/" >&2
    return 1
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Git helpers
# ─────────────────────────────────────────────────────────────────────────────

# Resolve a worktree identifier (path or branch name) to an absolute worktree path.
# Tries:
#   1. Filesystem path (directory must exist) — preserves existing behavior
#   2. Exact branch name match via `git worktree list --porcelain`
# Note: Detached HEAD worktrees cannot be resolved by branch name; use the path instead.
# Usage: wt_resolve_worktree <identifier>
# Outputs: absolute path on stdout
# Returns: 0 on success, 1 if not found
wt_resolve_worktree() {
  local identifier="$1"

  # 1) Try as filesystem path
  if [[ -d "$identifier" ]]; then
    (cd "$identifier" && pwd)
    return 0
  fi

  # 2) Try as exact branch name
  local wt_path="" branch=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        if [[ "$branch" == "$identifier" ]]; then
          (cd "$wt_path" 2>/dev/null && pwd) && return 0
        fi
        ;;
    esac
  done < <(git -C "$WT_MAIN_REPO_ROOT" worktree list --porcelain 2>/dev/null)

  return 1
}

# Resolve a worktree identifier and validate it's a git worktree.
# Combines wt_resolve_worktree + git-worktree validation.
# Usage: wt_resolve_and_validate <identifier>
# Outputs: absolute path on stdout
# Returns: 0 on success, 1 on failure (with error message on stderr)
wt_resolve_and_validate() {
  local identifier="$1"
  local resolved
  if ! resolved="$(wt_resolve_worktree "$identifier")"; then
    error "Worktree not found (not a valid path or branch name): $identifier"
    return 1
  fi
  if ! git -C "$resolved" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    error "$resolved is not a git repository or worktree"
    return 1
  fi
  printf '%s\n' "$resolved"
}

# List branch names of active worktrees.
# Usage: wt_worktree_branch_list [exclude_main]
# Outputs: one branch name per line to stdout
# Note: Detached HEAD worktrees are excluded (no branch name to emit).
wt_worktree_branch_list() {
  local exclude_main="${1:-}"
  local main_repo_abs=""

  if [[ "$exclude_main" == "exclude_main" && -n "${WT_MAIN_REPO_ROOT:-}" ]]; then
    main_repo_abs="$(cd "$WT_MAIN_REPO_ROOT" 2>/dev/null && pwd)"
  fi

  local wt_path="" wt_abs="" branch=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        wt_abs="$(cd "$wt_path" 2>/dev/null && pwd)" || continue
        if [[ -z "$main_repo_abs" || "$wt_abs" != "$main_repo_abs" ]]; then
          branch="${line#branch refs/heads/}"
          printf '%s\n' "$branch"
        fi
        ;;
    esac
  done < <(git -C "$WT_MAIN_REPO_ROOT" worktree list --porcelain 2>/dev/null)
}

# Get the currently linked worktree path (resolves symlink)
# Usage: wt_get_linked_worktree
# Outputs: absolute physical path to linked worktree, or empty if none
#
# Returns physical paths (pwd -P) to ensure consistent comparison with
# git worktree list output, which also uses physical paths. This handles
# macOS symlink quirks like /var -> /private/var.
wt_get_linked_worktree() {
  local link_path="$WT_ACTIVE_WORKTREE"

  # Normalize link path to physical path for consistent comparison
  if [[ -d "$(dirname "$link_path")" ]]; then
    link_path="$(cd "$(dirname "$link_path")" && pwd -P)/$(basename "$link_path")"
  fi

  if [[ -L "$link_path" ]]; then
    local target
    target="$(readlink "$link_path")"
    # Resolve to physical path whether target is relative or absolute
    if [[ "$target" != /* ]]; then
      target="$(cd "$(dirname "$link_path")" && cd "$(dirname "$target")" && pwd -P)/$(basename "$target")"
    else
      target="$(cd "$(dirname "$target")" && pwd -P)/$(basename "$target")"
    fi
    echo "$target"
  fi
}

# Format a worktree entry for display
# Usage: wt_format_worktree <worktree_path> [main_repo_abs] [linked_worktree] [verbose]
# Outputs: formatted string like "~/path (branch) [main] [linked] [dirty] [↑N] [↓N]"
# When verbose is "true", includes slow status checks (dirty, ahead/behind)
wt_format_worktree() {
  local wt_abs="$1"
  local main_repo_abs="${2:-}"
  local linked_worktree="${3:-}"
  local verbose="${4:-false}"

  # Get branch name
  local branch
  branch="$(git -C "$wt_abs" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")"

  # Build indicator string
  local indicators=""

  # Check if this is the main repo (fast - just string compare)
  if [[ -n "$main_repo_abs" && "$wt_abs" == "$main_repo_abs" ]]; then
    indicators="${indicators}${YELLOW}[main]${NC} "
  fi

  # Check if this is the currently linked worktree (fast - just string compare)
  if [[ -n "$linked_worktree" && "$wt_abs" == "$linked_worktree" ]]; then
    indicators="${indicators}${GREEN}[linked]${NC} "
  fi

  # Slow status checks - only when verbose mode is enabled
  if [[ "$verbose" == "true" ]]; then
    # Check for uncommitted changes (SLOW - runs git status)
    if wt_has_uncommitted_changes "$wt_abs"; then
      indicators="${indicators}${RED}[dirty]${NC} "
    fi

    # Check ahead/behind upstream (can be slow for repos with many commits)
    if [[ "$branch" != "detached" && "$branch" != "HEAD" ]]; then
      local upstream
      upstream="$(git -C "$wt_abs" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null || true)"
      if [[ -n "$upstream" ]]; then
        local counts
        counts="$(git -C "$wt_abs" rev-list --left-right --count "$branch...$upstream" 2>/dev/null || true)"
        if [[ -n "$counts" ]]; then
          local ahead behind
          ahead="$(echo "$counts" | cut -f1)"
          behind="$(echo "$counts" | cut -f2)"
          [[ "$ahead" -gt 0 ]] && indicators="${indicators}${GREEN}[↑${ahead}]${NC} "
          [[ "$behind" -gt 0 ]] && indicators="${indicators}${YELLOW}[↓${behind}]${NC} "
        fi
      fi
    fi
  fi

  # Output formatted entry
  printf "${BOLD}%s${NC} ${BLUE}(%s)${NC} %s" "$wt_abs" "$branch" "$indicators"
}

# Check if a worktree has uncommitted changes
# Usage: wt_has_uncommitted_changes <worktree-path>
# Returns: 0 if uncommitted changes exist, 1 if clean
wt_has_uncommitted_changes() {
  local worktree="$1"

  if [[ ! -d "$worktree" ]]; then
    return 1
  fi

  # Check for uncommitted changes (staged + unstaged + untracked)
  local status
  status="$(git -C "$worktree" status --porcelain 2>/dev/null)"

  if [[ -n "$status" ]]; then
    return 0  # Has uncommitted changes
  else
    return 1  # Clean
  fi
}

# Get summary of uncommitted changes in a worktree
# Usage: wt_uncommitted_summary <worktree-path>
# Outputs summary to stdout
wt_uncommitted_summary() {
  local worktree="$1"
  local staged unstaged untracked

  staged=$(git -C "$worktree" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  unstaged=$(git -C "$worktree" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  untracked=$(git -C "$worktree" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

  local parts=()
  [[ "$staged" -gt 0 ]] && parts+=("$staged staged")
  [[ "$unstaged" -gt 0 ]] && parts+=("$unstaged modified")
  [[ "$untracked" -gt 0 ]] && parts+=("$untracked untracked")

  if [[ ${#parts[@]} -gt 0 ]]; then
    echo "${parts[*]}"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# Prompts
# ═══════════════════════════════════════════════════════════════════════════════

# Prompt for confirmation with Ctrl-C handling
# Args:
#   $1 = prompt message (without trailing space)
#   $2 = default behavior: "y" (default yes), "n" (default no), or "" (require input)
# Returns:
#   0 if confirmed, 1 if declined or Ctrl-C
# Example:
#   if prompt_confirm "Proceed with operation? [Y/n]" "y"; then ...
#   if prompt_confirm "Delete everything? [y/N]" "n"; then ...
prompt_confirm() {
  local prompt="$1"
  local default="${2:-}"
  local response

  if ! read -erp "$prompt " response; then
    # Ctrl-C or EOF
    echo
    return 1
  fi

  # Empty response uses default
  if [[ -z "$response" ]]; then
    response="$default"
  fi

  case "$response" in
    [yY]|[yY][eE][sS])
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}
