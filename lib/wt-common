#!/usr/bin/env bash
#
# wt-common — Shared config and helpers for wt-* scripts
# =========================================================
#
# Centralizes paths and small helpers used by the worktree tooling suite:
#   - wt-add
#   - wt-switch
#   - wt-choose
#   - wt-metadata-import
#   - wt-metadata-export
#   - wt-remove
#

# Main monorepo root (where `git worktree` is managed)
# Default assumes a repo named "repo" - install.sh will configure the actual name
: "${WT_MAIN_REPO_ROOT:="$HOME/.wt/repos/repo/base"}"

# Base directory where new worktrees will be created by default
: "${WT_WORKTREES_BASE:="$HOME/.wt/repos/repo/worktrees"}"

# Base directory for project metadata vault (IDE configs: .ijwb, .idea, .vscode, etc.)
: "${WT_IDEA_FILES_BASE:="$HOME/.wt/repos/repo/idea-files"}"

# Symlink path that points to the currently active worktree (for IDE integration)
: "${WT_ACTIVE_WORKTREE:="$HOME/Development/java"}"

# Default primary branch to sync from when creating new worktrees
: "${WT_BASE_BRANCH:="master"}"

# Project metadata patterns to preserve across worktrees (space-separated)
# Detected during install, can be customized later
: "${WT_METADATA_PATTERNS:=""}"

# ─────────────────────────────────────────────────────────────────────────────
# Known project metadata patterns (for detection)
# Format: pattern:description
# ─────────────────────────────────────────────────────────────────────────────
WT_KNOWN_METADATA=(
  # JetBrains IDEs
  ".idea:JetBrains IDEs (IntelliJ, WebStorm, PyCharm, etc.)"
  ".run:JetBrains run/debug configurations"
  ".fleet:JetBrains Fleet"
  # Bazel
  ".ijwb:IntelliJ + Bazel plugin (legacy)"
  ".aswb:Android Studio + Bazel plugin (legacy)"
  ".clwb:CLion + Bazel plugin (legacy)"
  ".bazelbsp:JetBrains Bazel plugin (new, BSP-based)"
  ".bsp:Build Server Protocol (Scala, Java, Bazel)"
  # Xcode / iOS
  ".swiftpm:Swift Package Manager metadata"
  "xcuserdata:Xcode user data (breakpoints, UI state)"
  # VS Code
  ".vscode:Visual Studio Code"
  # Scala
  ".metals:Metals LSP (Scala)"
  ".bloop:Bloop build server (Scala)"
  # Eclipse
  ".settings:Eclipse settings"
  ".project:Eclipse project"
  ".classpath:Eclipse classpath"
)

# ─────────────────────────────────────────────────────────────────────────────
# Color support (only if output is a TTY)
# ─────────────────────────────────────────────────────────────────────────────
# Check if either stdout or stderr is a TTY (for interactive use)
# Use $'...' syntax to ensure escape sequences are properly interpreted
if [[ -t 1 || -t 2 ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[1;33m'
  BLUE=$'\033[0;34m'
  BOLD=$'\033[1m'
  NC=$'\033[0m' # No Color
else
  RED=''
  GREEN=''
  YELLOW=''
  BLUE=''
  BOLD=''
  NC=''
fi

# ─────────────────────────────────────────────────────────────────────────────
# Output helpers
# ─────────────────────────────────────────────────────────────────────────────

# Print to stderr (for UI messages, prompts, etc.)
echoerr() {
  printf "%s\n" "$*" >&2
}

# Print error message with red "Error:" prefix to stderr
error() {
  printf "${RED}Error:${NC} %s\n" "$*" >&2
}

# Print success message with green checkmark to stdout
success() {
  printf "${GREEN}✓${NC} %s\n" "$*"
}

# Print warning message with yellow warning symbol to stderr
warn() {
  printf "${YELLOW}⚠${NC}  %s\n" "$*" >&2
}

# Print info message with blue info symbol to stdout
info() {
  printf "${BLUE}ℹ${NC}  %s\n" "$*"
}

# Source a library script from lib/ directory
# Usage: wt_source <script_name>
# Requires LIB_DIR to be set by the calling script (usually SCRIPT_DIR/../lib)
wt_source() {
  local script="$1"
  local lib_dir="${LIB_DIR:-}"

  if [[ -z "$lib_dir" ]]; then
    echo "Error: LIB_DIR not set before calling wt_source" >&2
    return 1
  fi

  if [[ -f "$lib_dir/$script" ]]; then
    . "$lib_dir/$script"
  elif [[ -f "$HOME/.wt/lib/$script" ]]; then
    . "$HOME/.wt/lib/$script"
  else
    echo "Error: Cannot find $script in $lib_dir or ~/.wt/lib/" >&2
    return 1
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Git helpers
# ─────────────────────────────────────────────────────────────────────────────

# Get the currently linked worktree path (resolves symlink)
# Usage: wt_get_linked_worktree
# Outputs: absolute path to linked worktree, or empty if none
wt_get_linked_worktree() {
  local link_path="$WT_ACTIVE_WORKTREE"
  
  # Normalize link path
  if [[ -d "$(dirname "$link_path")" ]]; then
    link_path="$(cd "$(dirname "$link_path")" && pwd)/$(basename "$link_path")"
  fi
  
  if [[ -L "$link_path" ]]; then
    local target
    target="$(readlink "$link_path")"
    # Normalize relative symlinks to absolute
    if [[ "$target" != /* ]]; then
      target="$(cd "$(dirname "$link_path")" && cd "$(dirname "$target")" && pwd)/$(basename "$target")"
    fi
    echo "$target"
  fi
}

# Format a worktree entry for display
# Usage: wt_format_worktree <worktree_path> [main_repo_abs] [linked_worktree] [verbose]
# Outputs: formatted string like "~/path (branch) [main] [linked] [dirty] [↑N] [↓N]"
# When verbose is "true", includes slow status checks (dirty, ahead/behind)
wt_format_worktree() {
  local wt_abs="$1"
  local main_repo_abs="${2:-}"
  local linked_worktree="${3:-}"
  local verbose="${4:-false}"
  
  # Get branch name
  local branch
  branch="$(git -C "$wt_abs" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")"
  
  # Build indicator string
  local indicators=""
  
  # Check if this is the main repo (fast - just string compare)
  if [[ -n "$main_repo_abs" && "$wt_abs" == "$main_repo_abs" ]]; then
    indicators="${indicators}${YELLOW}[main]${NC} "
  fi
  
  # Check if this is the currently linked worktree (fast - just string compare)
  if [[ -n "$linked_worktree" && "$wt_abs" == "$linked_worktree" ]]; then
    indicators="${indicators}${GREEN}[linked]${NC} "
  fi
  
  # Slow status checks - only when verbose mode is enabled
  if [[ "$verbose" == "true" ]]; then
    # Check for uncommitted changes (SLOW - runs git status)
    if wt_has_uncommitted_changes "$wt_abs"; then
      indicators="${indicators}${RED}[dirty]${NC} "
    fi
    
    # Check ahead/behind upstream (can be slow for repos with many commits)
    if [[ "$branch" != "detached" && "$branch" != "HEAD" ]]; then
      local upstream
      upstream="$(git -C "$wt_abs" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null || true)"
      if [[ -n "$upstream" ]]; then
        local counts
        counts="$(git -C "$wt_abs" rev-list --left-right --count "$branch...$upstream" 2>/dev/null || true)"
        if [[ -n "$counts" ]]; then
          local ahead behind
          ahead="$(echo "$counts" | cut -f1)"
          behind="$(echo "$counts" | cut -f2)"
          [[ "$ahead" -gt 0 ]] && indicators="${indicators}${GREEN}[↑${ahead}]${NC} "
          [[ "$behind" -gt 0 ]] && indicators="${indicators}${YELLOW}[↓${behind}]${NC} "
        fi
      fi
    fi
  fi
  
  # Output formatted entry
  printf "${BOLD}%s${NC} ${BLUE}(%s)${NC} %s" "$wt_abs" "$branch" "$indicators"
}

# Check if a worktree has uncommitted changes
# Usage: wt_has_uncommitted_changes <worktree-path>
# Returns: 0 if uncommitted changes exist, 1 if clean
wt_has_uncommitted_changes() {
  local worktree="$1"
  
  if [[ ! -d "$worktree" ]]; then
    return 1
  fi
  
  # Check for uncommitted changes (staged + unstaged + untracked)
  local status
  status="$(git -C "$worktree" status --porcelain 2>/dev/null)"
  
  if [[ -n "$status" ]]; then
    return 0  # Has uncommitted changes
  else
    return 1  # Clean
  fi
}

# Get summary of uncommitted changes in a worktree
# Usage: wt_uncommitted_summary <worktree-path>
# Outputs summary to stdout
wt_uncommitted_summary() {
  local worktree="$1"
  local staged unstaged untracked
  
  staged=$(git -C "$worktree" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  unstaged=$(git -C "$worktree" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  untracked=$(git -C "$worktree" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
  
  local parts=()
  [[ "$staged" -gt 0 ]] && parts+=("$staged staged")
  [[ "$unstaged" -gt 0 ]] && parts+=("$unstaged modified")
  [[ "$untracked" -gt 0 ]] && parts+=("$untracked untracked")
  
  if [[ ${#parts[@]} -gt 0 ]]; then
    echo "${parts[*]}"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# Prompts
# ═══════════════════════════════════════════════════════════════════════════════

# Prompt for confirmation with Ctrl-C handling
# Args:
#   $1 = prompt message (without trailing space)
#   $2 = default behavior: "y" (default yes), "n" (default no), or "" (require input)
# Returns:
#   0 if confirmed, 1 if declined or Ctrl-C
# Example:
#   if prompt_confirm "Proceed with operation? [Y/n]" "y"; then ...
#   if prompt_confirm "Delete everything? [y/N]" "n"; then ...
prompt_confirm() {
  local prompt="$1"
  local default="${2:-}"
  local response

  if ! read -rp "$prompt " response; then
    # Ctrl-C or EOF
    echo
    return 1
  fi

  # Empty response uses default
  if [[ -z "$response" ]]; then
    response="$default"
  fi

  case "$response" in
    [yY]|[yY][eE][sS])
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

