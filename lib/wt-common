#!/usr/bin/env bash
#
# wt-common — Shared config and helpers for wt-* scripts
# =========================================================
#
# Centralizes paths and small helpers used by the worktree tooling suite:
#   - wt-add
#   - wt-switch
#   - wt-choose
#   - wt-metadata-import
#   - wt-metadata-export
#   - wt-remove
#

# ─────────────────────────────────────────────────────────────────────────────
# Multi-repo context support
# ─────────────────────────────────────────────────────────────────────────────
# The wt toolkit supports multiple repository contexts. Each context has its
# own configuration stored in ~/.wt/repos/<name>.conf
#
# Configuration is loaded at runtime via parsing (not sourcing), so context
# switches take effect immediately without requiring shell reload.
# ─────────────────────────────────────────────────────────────────────────────

# Clear all WT_* config variables to allow fresh reload
# Used before wt_read_config() when we need to pick up context changes
# in the current shell (e.g., completions, help)
wt_clear_config_vars() {
  unset WT_MAIN_REPO_ROOT
  unset WT_WORKTREES_BASE
  unset WT_IDEA_FILES_BASE
  unset WT_ACTIVE_WORKTREE
  unset WT_BASE_BRANCH
  unset WT_METADATA_PATTERNS
  unset WT_CONTEXT_NAME
}

# Parse config file into shell variables (no sourcing)
# Only sets variables that aren't already set in the environment
# Args: $1 = config file path (default: ~/.wt/current)
#       $2 = "force" to clear existing variables first (for in-shell reload)
#
# When reading ~/.wt/current, it contains just the context name.
# The actual config is then loaded from ~/.wt/repos/<name>.conf
wt_read_config() {
  local config_file="${1:-$HOME/.wt/current}"
  local force="${2:-}"

  # If force mode, clear existing variables first (for in-shell reload after context switch)
  if [[ "$force" == "force" ]]; then
    wt_clear_config_vars
  fi

  [[ ! -f "$config_file" ]] && return 1

  # If this is the current context file, read context name and load from .conf
  if [[ "$config_file" == "$HOME/.wt/current" ]]; then
    local context_name
    context_name="$(head -1 "$config_file" | tr -d '[:space:]')"
    [[ -z "$context_name" ]] && return 1

    # Set context name for display purposes
    : "${WT_CONTEXT_NAME:="$context_name"}"

    # Now read the actual config from .conf file
    config_file="$HOME/.wt/repos/${context_name}.conf"
    [[ ! -f "$config_file" ]] && return 1
  fi

  local key value current_val
  while IFS='=' read -r key value; do
    # Skip empty lines and comments
    [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
    # Strip quotes from value
    value="${value#\"}"
    value="${value%\"}"
    # Only set if not already set in environment (allows env override)
    # Use eval with proper escaping for both bash and zsh compatibility
    eval "current_val=\"\${$key:-}\""
    if [[ -z "$current_val" ]]; then
      eval "$key=\"\$value\""
    fi
  done < <(grep -E '^WT_[A-Z_]+=' "$config_file" 2>/dev/null)
}

# Load config from current file, then apply fallback defaults
wt_read_config "$HOME/.wt/current" 2>/dev/null || true

# Fallback defaults (used when no context is configured or config missing values)
# These provide backward compatibility for single-repo setups
# Main monorepo root (where `git worktree` is managed)
: "${WT_MAIN_REPO_ROOT:="$HOME/.wt/repos/repo/base"}"

# Base directory where new worktrees will be created by default
: "${WT_WORKTREES_BASE:="$HOME/.wt/repos/repo/worktrees"}"

# Base directory for project metadata vault (IDE configs: .ijwb, .idea, .vscode, etc.)
: "${WT_IDEA_FILES_BASE:="$HOME/.wt/repos/repo/idea-files"}"

# Symlink path that points to the currently active worktree (for IDE integration)
: "${WT_ACTIVE_WORKTREE:="$HOME/Development/java"}"

# Default primary branch to sync from when creating new worktrees
: "${WT_BASE_BRANCH:="master"}"

# Project metadata patterns to preserve across worktrees (space-separated)
: "${WT_METADATA_PATTERNS:=""}"

# Context name (for display purposes)
: "${WT_CONTEXT_NAME:=""}"

# ─────────────────────────────────────────────────────────────────────────────
# Known project metadata patterns (for detection)
# Format: pattern:description
# ─────────────────────────────────────────────────────────────────────────────
WT_KNOWN_METADATA=(
  # JetBrains IDEs
  ".idea:JetBrains IDEs (IntelliJ, WebStorm, PyCharm, etc.)"
  ".run:JetBrains run/debug configurations"
  ".fleet:JetBrains Fleet"
  # Bazel
  ".ijwb:IntelliJ + Bazel plugin (legacy)"
  ".aswb:Android Studio + Bazel plugin (legacy)"
  ".clwb:CLion + Bazel plugin (legacy)"
  ".bazelbsp:JetBrains Bazel plugin (new, BSP-based)"
  ".bsp:Build Server Protocol (Scala, Java, Bazel)"
  # Xcode / iOS
  ".swiftpm:Swift Package Manager metadata"
  "xcuserdata:Xcode user data (breakpoints, UI state)"
  # VS Code
  ".vscode:Visual Studio Code"
  # Scala
  ".metals:Metals LSP (Scala)"
  ".bloop:Bloop build server (Scala)"
  # Eclipse
  ".settings:Eclipse settings"
  ".project:Eclipse project"
  ".classpath:Eclipse classpath"
)

# ─────────────────────────────────────────────────────────────────────────────
# Color support (only if output is a TTY)
# ─────────────────────────────────────────────────────────────────────────────
# Check if either stdout or stderr is a TTY (for interactive use)
# Use $'...' syntax to ensure escape sequences are properly interpreted
if [[ -t 1 || -t 2 ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[1;33m'
  BLUE=$'\033[0;34m'
  BOLD=$'\033[1m'
  NC=$'\033[0m' # No Color
else
  RED=''
  GREEN=''
  YELLOW=''
  BLUE=''
  BOLD=''
  NC=''
fi

# ─────────────────────────────────────────────────────────────────────────────
# Output helpers
# ─────────────────────────────────────────────────────────────────────────────

# Print to stderr (for UI messages, prompts, etc.)
echoerr() {
  printf "%s\n" "$*" >&2
}

# Print error message with red "Error:" prefix to stderr
error() {
  printf "${RED}Error:${NC} %s\n" "$*" >&2
}

# Print success message with green checkmark to stdout
success() {
  printf "${GREEN}✓${NC} %s\n" "$*"
}

# Print warning message with yellow warning symbol to stderr
warn() {
  printf "${YELLOW}⚠${NC}  %s\n" "$*" >&2
}

# Print info message with blue info symbol to stdout
info() {
  printf "${BLUE}ℹ${NC}  %s\n" "$*"
}

# Show the context banner if contexts are configured
# Output goes to stderr so it doesn't interfere with command output
wt_show_context_banner() {
  local repos_dir="$HOME/.wt/repos"
  local current_context=""

  # Only show banner if contexts are configured
  if [[ ! -d "$repos_dir" ]] || ! compgen -G "$repos_dir/*.conf" >/dev/null 2>&1; then
    return 0
  fi

  # Read current context name from ~/.wt/current
  if [[ -f "$HOME/.wt/current" ]]; then
    current_context="$(head -1 "$HOME/.wt/current" | tr -d '[:space:]')"
  fi

  if [[ -n "$current_context" ]]; then
    printf "${BLUE}[Context: %s]${NC} ${YELLOW}(wt context to switch)${NC}\n" "$current_context" >&2
  else
    printf "${YELLOW}[No context set]${NC} ${YELLOW}(wt context to switch)${NC}\n" >&2
  fi
}

# Source a library script from lib/ directory
# Usage: wt_source <script_name>
# Requires LIB_DIR to be set by the calling script (usually SCRIPT_DIR/../lib)
wt_source() {
  local script="$1"
  local lib_dir="${LIB_DIR:-}"

  if [[ -z "$lib_dir" ]]; then
    echo "Error: LIB_DIR not set before calling wt_source" >&2
    return 1
  fi

  if [[ -f "$lib_dir/$script" ]]; then
    . "$lib_dir/$script"
  elif [[ -f "$HOME/.wt/lib/$script" ]]; then
    . "$HOME/.wt/lib/$script"
  else
    echo "Error: Cannot find $script in $lib_dir or ~/.wt/lib/" >&2
    return 1
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Git helpers
# ─────────────────────────────────────────────────────────────────────────────

# Resolve a worktree identifier (path or branch name) to an absolute worktree path.
# Tries:
#   1. Filesystem path (directory must exist) — preserves existing behavior
#   2. Exact branch name match via `git worktree list --porcelain`
# Note: Detached HEAD worktrees cannot be resolved by branch name; use the path instead.
# Usage: wt_resolve_worktree <identifier>
# Outputs: absolute path on stdout
# Returns: 0 on success, 1 if not found
wt_resolve_worktree() {
  local identifier="$1"

  # 1) Try as filesystem path
  if [[ -d "$identifier" ]]; then
    (cd "$identifier" && pwd)
    return 0
  fi

  # 2) Try as exact branch name
  local wt_path="" branch=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        branch="${line#branch refs/heads/}"
        if [[ "$branch" == "$identifier" ]]; then
          (cd "$wt_path" 2>/dev/null && pwd) && return 0
        fi
        ;;
    esac
  done < <(git -C "$WT_MAIN_REPO_ROOT" worktree list --porcelain 2>/dev/null)

  return 1
}

# Resolve a worktree identifier and validate it's a git worktree.
# Combines wt_resolve_worktree + git-worktree validation.
# Usage: wt_resolve_and_validate <identifier>
# Outputs: absolute path on stdout
# Returns: 0 on success, 1 on failure (with error message on stderr)
wt_resolve_and_validate() {
  local identifier="$1"
  local resolved
  if ! resolved="$(wt_resolve_worktree "$identifier")"; then
    error "Worktree not found (not a valid path or branch name): $identifier"
    return 1
  fi
  if ! git -C "$resolved" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    error "$resolved is not a git repository or worktree"
    return 1
  fi
  printf '%s\n' "$resolved"
}

# List branch names of active worktrees.
# Usage: wt_worktree_branch_list [exclude_main]
# Outputs: one branch name per line to stdout
# Note: Detached HEAD worktrees are excluded (no branch name to emit).
wt_worktree_branch_list() {
  local exclude_main="${1:-}"
  local main_repo_abs=""

  if [[ "$exclude_main" == "exclude_main" && -n "${WT_MAIN_REPO_ROOT:-}" ]]; then
    main_repo_abs="$(cd "$WT_MAIN_REPO_ROOT" 2>/dev/null && pwd)"
  fi

  local wt_path="" wt_abs="" branch=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        wt_path="${line#worktree }"
        ;;
      branch\ *)
        wt_abs="$(cd "$wt_path" 2>/dev/null && pwd)" || continue
        if [[ -z "$main_repo_abs" || "$wt_abs" != "$main_repo_abs" ]]; then
          branch="${line#branch refs/heads/}"
          printf '%s\n' "$branch"
        fi
        ;;
    esac
  done < <(git -C "$WT_MAIN_REPO_ROOT" worktree list --porcelain 2>/dev/null)
}

# Get the currently linked worktree path (resolves symlink)
# Usage: wt_get_linked_worktree
# Outputs: absolute physical path to linked worktree, or empty if none
#
# Returns physical paths (pwd -P) to ensure consistent comparison with
# git worktree list output, which also uses physical paths. This handles
# macOS symlink quirks like /var -> /private/var.
wt_get_linked_worktree() {
  local link_path="$WT_ACTIVE_WORKTREE"

  # Normalize link path to physical path for consistent comparison
  if [[ -d "$(dirname "$link_path")" ]]; then
    link_path="$(cd "$(dirname "$link_path")" && pwd -P)/$(basename "$link_path")"
  fi

  if [[ -L "$link_path" ]]; then
    local target
    target="$(readlink "$link_path")"
    # Resolve to physical path whether target is relative or absolute
    if [[ "$target" != /* ]]; then
      target="$(cd "$(dirname "$link_path")" && cd "$(dirname "$target")" && pwd -P)/$(basename "$target")"
    else
      target="$(cd "$(dirname "$target")" && pwd -P)/$(basename "$target")"
    fi
    echo "$target"
  fi
}

# Format a worktree entry for display
# Usage: wt_format_worktree <worktree_path> [main_repo_abs] [linked_worktree] [verbose]
# Outputs: formatted string like "~/path (branch) [main] [linked] [dirty] [↑N] [↓N]"
# When verbose is "true", includes slow status checks (dirty, ahead/behind)
wt_format_worktree() {
  local wt_abs="$1"
  local main_repo_abs="${2:-}"
  local linked_worktree="${3:-}"
  local verbose="${4:-false}"

  # Get branch name
  local branch
  branch="$(git -C "$wt_abs" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")"

  # Build indicator string
  local indicators=""

  # Check if this is the main repo (fast - just string compare)
  if [[ -n "$main_repo_abs" && "$wt_abs" == "$main_repo_abs" ]]; then
    indicators="${indicators}${YELLOW}[main]${NC} "
  fi

  # Check if this is the currently linked worktree (fast - just string compare)
  if [[ -n "$linked_worktree" && "$wt_abs" == "$linked_worktree" ]]; then
    indicators="${indicators}${GREEN}[linked]${NC} "
  fi

  # Slow status checks - only when verbose mode is enabled
  if [[ "$verbose" == "true" ]]; then
    # Check for uncommitted changes (SLOW - runs git status)
    if wt_has_uncommitted_changes "$wt_abs"; then
      indicators="${indicators}${RED}[dirty]${NC} "
    fi

    # Check ahead/behind upstream (can be slow for repos with many commits)
    if [[ "$branch" != "detached" && "$branch" != "HEAD" ]]; then
      local upstream
      upstream="$(git -C "$wt_abs" rev-parse --abbrev-ref "@{upstream}" 2>/dev/null || true)"
      if [[ -n "$upstream" ]]; then
        local counts
        counts="$(git -C "$wt_abs" rev-list --left-right --count "$branch...$upstream" 2>/dev/null || true)"
        if [[ -n "$counts" ]]; then
          local ahead behind
          ahead="$(echo "$counts" | cut -f1)"
          behind="$(echo "$counts" | cut -f2)"
          [[ "$ahead" -gt 0 ]] && indicators="${indicators}${GREEN}[↑${ahead}]${NC} "
          [[ "$behind" -gt 0 ]] && indicators="${indicators}${YELLOW}[↓${behind}]${NC} "
        fi
      fi
    fi
  fi

  # Output formatted entry
  printf "${BOLD}%s${NC} ${BLUE}(%s)${NC} %s" "$wt_abs" "$branch" "$indicators"
}

# Check if a worktree has uncommitted changes
# Usage: wt_has_uncommitted_changes <worktree-path>
# Returns: 0 if uncommitted changes exist, 1 if clean
wt_has_uncommitted_changes() {
  local worktree="$1"

  if [[ ! -d "$worktree" ]]; then
    return 1
  fi

  # Check for uncommitted changes (staged + unstaged + untracked)
  local status
  status="$(git -C "$worktree" status --porcelain 2>/dev/null)"

  if [[ -n "$status" ]]; then
    return 0  # Has uncommitted changes
  else
    return 1  # Clean
  fi
}

# Get summary of uncommitted changes in a worktree
# Usage: wt_uncommitted_summary <worktree-path>
# Outputs summary to stdout
wt_uncommitted_summary() {
  local worktree="$1"
  local staged unstaged untracked

  staged=$(git -C "$worktree" diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  unstaged=$(git -C "$worktree" diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  untracked=$(git -C "$worktree" ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

  local parts=()
  [[ "$staged" -gt 0 ]] && parts+=("$staged staged")
  [[ "$unstaged" -gt 0 ]] && parts+=("$unstaged modified")
  [[ "$untracked" -gt 0 ]] && parts+=("$untracked untracked")

  if [[ ${#parts[@]} -gt 0 ]]; then
    echo "${parts[*]}"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# Prompts
# ═══════════════════════════════════════════════════════════════════════════════

# Prompt for confirmation with Ctrl-C handling
# Args:
#   $1 = prompt message (without trailing space)
#   $2 = default behavior: "y" (default yes), "n" (default no), or "" (require input)
# Returns:
#   0 if confirmed, 1 if declined or Ctrl-C
# Example:
#   if prompt_confirm "Proceed with operation? [Y/n]" "y"; then ...
#   if prompt_confirm "Delete everything? [y/N]" "n"; then ...
prompt_confirm() {
  local prompt="$1"
  local default="${2:-}"
  local response

  if ! read -rp "$prompt " response; then
    # Ctrl-C or EOF
    echo
    return 1
  fi

  # Empty response uses default
  if [[ -z "$response" ]]; then
    response="$default"
  fi

  case "$response" in
    [yY]|[yY][eE][sS])
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}
